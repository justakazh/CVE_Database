{
    "cve": {
        "id": "CVE-2024-53140",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-12-04T15:15:16.803",
        "lastModified": "2024-12-05T12:15:19.703",
        "vulnStatus": "Received",
        "cveTags": [],
        "descriptions": [
            {
                "lang": "en",
                "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: terminate outstanding dump on socket close\n\nNetlink supports iterative dumping of data. It provides the families\nthe following ops:\n - start - (optional) kicks off the dumping process\n - dump  - actual dump helper, keeps getting called until it returns 0\n - done  - (optional) pairs with .start, can be used for cleanup\nThe whole process is asynchronous and the repeated calls to .dump\ndon't actually happen in a tight loop, but rather are triggered\nin response to recvmsg() on the socket.\n\nThis gives the user full control over the dump, but also means that\nthe user can close the socket without getting to the end of the dump.\nTo make sure .start is always paired with .done we check if there\nis an ongoing dump before freeing the socket, and if so call .done.\n\nThe complication is that sockets can get freed from BH and .done\nis allowed to sleep. So we use a workqueue to defer the call, when\nneeded.\n\nUnfortunately this does not work correctly. What we defer is not\nthe cleanup but rather releasing a reference on the socket.\nWe have no guarantee that we own the last reference, if someone\nelse holds the socket they may release it in BH and we're back\nto square one.\n\nThe whole dance, however, appears to be unnecessary. Only the user\ncan interact with dumps, so we can clean up when socket is closed.\nAnd close always happens in process context. Some async code may\nstill access the socket after close, queue notification skbs to it etc.\nbut no dumps can start, end or otherwise make progress.\n\nDelete the workqueue and flush the dump state directly from the release\nhandler. Note that further cleanup is possible in -next, for instance\nwe now always call .done before releasing the main module reference,\nso dump doesn't have to take a reference of its own."
            },
            {
                "lang": "es",
                "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netlink: termina el volcado pendiente al cerrar el socket Netlink admite el volcado iterativo de datos. Proporciona a las familias las siguientes operaciones: - start - (opcional) inicia el proceso de volcado - dump - asistente de volcado real, se sigue llamando hasta que devuelve 0 - done - (opcional) se empareja con .start, se puede usar para limpieza Todo el proceso es asincr\u00f3nico y las llamadas repetidas a .dump en realidad no ocurren en un bucle cerrado, sino que se activan en respuesta a recvmsg() en el socket. Esto le da al usuario control total sobre el volcado, pero tambi\u00e9n significa que el usuario puede cerrar el socket sin llegar al final del volcado. Para asegurarnos de que .start siempre est\u00e9 emparejado con .done, verificamos si hay un volcado en curso antes de liberar el socket y, si es as\u00ed, llamamos a .done. La complicaci\u00f3n es que los sockets pueden liberarse de BH y se permite que .done duerma. Entonces, usamos una cola de trabajo para diferir la llamada, cuando sea necesario. Lamentablemente, esto no funciona correctamente. Lo que postergamos no es la limpieza, sino la liberaci\u00f3n de una referencia en el socket. No tenemos garant\u00eda de que seamos due\u00f1os de la \u00faltima referencia; si alguien m\u00e1s tiene el socket, puede liberarlo en BH y volvemos al punto de partida. Sin embargo, todo el baile parece ser innecesario. Solo el usuario puede interactuar con los volcados, por lo que podemos limpiar cuando se cierra el socket. Y el cierre siempre ocurre en el contexto del proceso. Es posible que alg\u00fan c\u00f3digo asincr\u00f3nico a\u00fan acceda al socket despu\u00e9s del cierre, ponga en cola skbs de notificaci\u00f3n, etc., pero ning\u00fan volcado puede comenzar, finalizar o avanzar de otro modo. Elimine la cola de trabajo y vac\u00ede el estado del volcado directamente desde el controlador de liberaci\u00f3n. Tenga en cuenta que es posible realizar una desinfecci\u00f3n adicional en -next, por ejemplo, ahora siempre llamamos a .done antes de liberar la referencia del m\u00f3dulo principal, por lo que el volcado no tiene que tomar una referencia propia."
            }
        ],
        "metrics": {},
        "references": [
            {
                "url": "https://git.kernel.org/stable/c/114a61d8d94ae3a43b82446cf737fd757021b834",
                "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
            },
            {
                "url": "https://git.kernel.org/stable/c/176c41b3ca9281a9736b67c6121b03dbf0c8c08f",
                "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
            },
            {
                "url": "https://git.kernel.org/stable/c/1904fb9ebf911441f90a68e96b22aa73e4410505",
                "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
            },
            {
                "url": "https://git.kernel.org/stable/c/4e87a52133284afbd40fb522dbf96e258af52a98",
                "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
            },
            {
                "url": "https://git.kernel.org/stable/c/bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca",
                "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
            }
        ]
    }
}